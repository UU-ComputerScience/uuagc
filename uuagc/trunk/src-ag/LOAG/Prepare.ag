INCLUDE "AbstractSyntax.ag"
INCLUDE "Patterns.ag"
INCLUDE "CodeSyntax.ag"
INCLUDE "Expression.ag"
INCLUDE "HsToken.ag"
INCLUDE "LOAG/Rep"
INCLUDE "ExecutionPlanPre"

MODULE {LOAG.Prepare}
{}
{}

imports{
import qualified Data.Array as A
import qualified Data.Map as M
import qualified Data.Set as S
import qualified Data.Sequence as Seq
import qualified CommonTypes as CT
import AbstractSyntax
import LOAG.Common
import LOAG.Chordal
import LOAG.Rep
import LOAG.Graphs
import CodeSyntax
import Data.Maybe (isJust, fromJust)
import ExecutionPlan
import GrammarInfo
import HsToken (HsToken(..))
import Pretty

import Debug.Trace
}


{
-- | Translating UUAGC types to MyTypes
drhs f | f == _LHS               = Inh
       | f == _LOC               = AnyDir
       | f == _INST              = AnyDir
       | otherwise               = Syn
dlhs f | f == _LHS               = Syn
       | f == _LOC               = AnyDir
       | f == _INST              = AnyDir
       | otherwise               = Inh 

depToEdge :: PMP_R -> PLabel -> Dependency -> Edge
depToEdge pmpr p e = 
    (findWithErr pmpr "depToEdge" $ MyOccurrence (p,getName f1) (getName i1, drhs f1),
     findWithErr pmpr "depToEdge" $ MyOccurrence (p,getName f2) (getName i2, dlhs f2))
    where Dependency (OccAttr f1 i1) (OccAttr f2 i2) = e

vertexToAttr :: NMP -> Vertex -> Attributes
vertexToAttr nmp v = M.singleton (identifier a) (fromMyTy ty)
    where (MyAttribute ty (a,_)) = findWithErr nmp "vertexToAttr" v

}

SEM Grammar | Grammar
    inst.smf : LOAGRep 
    loc.initO= if M.null @nonts.pmp then 1 else fst $ M.findMin @nonts.pmp
    inst.smf = 
        LOAGRep @nonts.ps @nonts.ap @loc.an 
           @loc.ain @loc.asn @loc.sfp
           @nonts.pmp @nonts.pmpr @loc.nmp @loc.nmpr
           (A.array (@loc.initO, @loc.initO + M.size @nonts.gen)  $ 
                M.toList $ @nonts.gen)
           (A.array (1,M.size @nonts.inss) $ 
                M.toList $ @nonts.inss)
           (A.array (@loc.initO, @loc.initO + length @nonts.ofld) $ 
                @nonts.ofld) @nonts.fty @nonts.fieldMap @nonts.fsInP
    loc.nmp  = M.fromList $ zip [1..] @loc.atts
    loc.nmpr = M.fromList $ zip @loc.atts [1..]
    loc.an   = M.unionWith (++) @loc.ain @loc.asn
    loc.ain  = @nonts.inhs
    loc.asn  = @nonts.syns
    loc.atts = concat $ M.elems @loc.an
    loc.occs = concat $ M.elems @nonts.ap
    nonts.augM = @manualAttrOrderMap

-- Collecting the attributes 
ATTR Nonterminals Nonterminal [
    augM   : {M.Map Identifier (M.Map Identifier (S.Set Dependency))} ||  
    inhs USE {M.union} {M.empty} : AI_N 
    syns USE {M.union} {M.empty} : AS_N ]
    
SEM Nonterminal | Nonterminal 
    lhs.inhs = let dty = TyData (getName @nt) 
                in M.singleton dty (toMyAttr Inh dty @inh)
    lhs.syns = let dty = TyData (getName @nt) 
                in M.singleton dty (toMyAttr Syn dty @syn)
    prods.augM = case M.lookup @nt @lhs.augM of
                    Nothing -> M.empty 
                    Just a  -> a

-- Adding all attribute sets to the AG type 
--   and sending it all down the abstract tree
ATTR Nonterminals Nonterminal Productions Production Children Child 
    MySegments MySegment [
    ain   : {MyType -> MyAttributes} 
    asn   : {MyType -> MyAttributes}
    pmpf  : PMP
    pmprf : PMP_R
    lfpf  : SF_P
    hoMapf: HOMap
    fty   : FTY
    nmp   : NMP || ]

SEM Grammar | Grammar
    nonts.ain  = map2F @loc.ain
    nonts.asn  = map2F @loc.asn
    nonts.pmpf  = @nonts.pmp
    nonts.pmprf = @nonts.pmpr
    nonts.lfpf  = @nonts.lfp
    nonts.hoMapf= @nonts.hoMap
    nonts.ftyf  = @nonts.fty
    nonts.fty   = @nonts.fty

-- Make sure TDP AND LFPRF are passed around correctly to code-generation
ATTR Nonterminals Nonterminal Productions Production [
    ftyf: FTY ||]


-- Calculate the set of production labels
SEM Grammar | Grammar 
     loc.ps = @nonts.ps
ATTR Nonterminals Nonterminal Productions Production [ || 
    ads USE {(++)} {[]}   : {[Edge]}
    fieldMap USE {(M.union)} {M.empty} : FMap
    hoMap    USE {(M.union)} {M.empty} : HOMap
    fsInP USE {(M.union)} {M.empty} : FsInP]

SEM Nonterminals Nonterminal [ ||
    ps  USE {(++)} {([])} : {[PLabel]} ]
SEM Productions [ ||
    ps  USE {:} {([])} : {[PLabel]}  ]
SEM Production [ || ps : PLabel ] | Production 
    loc.ps = (@lhs.dty,getName @con)
    lhs.ads   = 
        case M.lookup @con @lhs.augM of
         Nothing -> []
         Just a  -> S.toList $ S.map (depToEdge @children.pmpr @loc.pll) a
    children.dty = @lhs.dty

ATTR Productions Production [
   augM : {M.Map Identifier (S.Set Dependency)} || ]
-- We didnt calculate A_P yet, inheriting A_N we can
ATTR Productions Production Rules Rule [ 
    -- result type of this constructor 
    dty : {MyType} || ]
ATTR Rules Rule Children Child Expression HsTokensRoot HsTokens HsToken [
    pll : {PLabel} || ]
SEM Nonterminal | Nonterminal    
    loc.dty  = TyData (getName @nt)

ATTR Nonterminals Nonterminal Productions Production Children Child 
     FieldAtts FieldAtt [
    an      : {MyType -> MyAttributes} 
    nmprf   : NMP_R|
    olab    : Int --  chained attribute for handing out labels to occurrences
    flab    : Int  |--chained attribute for handing out labels to fields
    ap   USE {M.unionWith (++)} {M.empty}   : A_P
    gen  USE {M.union}          {M.empty}   : {Map Int Int}
    inss USE {M.unionWith (++)} {M.empty}   : {Map Int [Int]}
    pmp  USE {M.union}          {M.empty}   : PMP
    pmpr USE {M.union}          {M.empty}   : PMP_R
    -- maps for each occurrence to which field it belongs
    ofld USE {(++)}             {[]}        : {[(Int, Int)]}
    fty  USE {M.union}          {M.empty}   : FTY
    ]

SEM Grammar | Grammar 
    nonts.an = map2F @loc.an
    nonts.nmprf= @loc.nmpr
    nonts.olab = if M.null @loc.nmp then 0 else (fst $ M.findMax @loc.nmp)
    nonts.flab = 0

ATTR Children Child [||
    fieldMap USE {M.union} {M.empty} : FMap
    hoMap    USE {M.unionWith (S.union)} {M.empty} : HOMap
    ]
SEM Children [ dty : {MyType} || ]
    | Nil 
    loc.flab    = @lhs.flab + 1
    loc.atp     = fst @lhs.pll
    inst.fatts  : FieldAtts
    inst.fatts  = map ((FieldAtt @loc.atp @lhs.pll "lhs") . alab) $ 
                        @lhs.an @loc.atp
    fatts.flab  = @loc.flab
    loc.label   = (@lhs.pll, "lhs")
    loc.foccsI  = S.fromList $ handAllOut @loc.label $ @lhs.ain @loc.atp
    loc.foccsS  = S.fromList $ handAllOut @loc.label $ @lhs.asn @loc.atp
    loc.fieldMap= M.singleton @loc.label (@loc.foccsI, @loc.foccsS)
    lhs.fty     = M.singleton @loc.label @lhs.dty

SEM Child | Child
    loc.flab    = @lhs.flab + 1
    loc.atp     = toMyTy @tp
    inst.fatts  : FieldAtts
    inst.fatts  = map ((FieldAtt @loc.atp @lhs.pll (getName @name)) . alab)
                        $ @lhs.an @loc.atp
    fatts.flab  = @loc.flab
    loc.ident   = getName @name
    loc.label   = (@lhs.pll, @loc.ident)
    loc.foccsI  = S.fromList $ handAllOut @loc.label $ @lhs.ain @loc.atp
    loc.foccsS  = S.fromList $ handAllOut @loc.label $ @lhs.asn @loc.atp
    loc.fieldMap= if S.null @loc.foccsI && S.null @loc.foccsS
                        then M.empty 
                        else M.singleton @loc.label (@loc.foccsS,@loc.foccsI)
    loc.hoMap   = case @kind of
                    ChildAttr -> M.singleton @lhs.pll (S.singleton @loc.ident)
                    _         -> M.empty
    lhs.fty     = M.singleton (@lhs.pll, getName @name) @loc.atp

SEM FieldAtt | FieldAtt
    loc.olab    = @lhs.olab + 1
    loc.alab    = findWithErr @lhs.nmprf "getting attr label" @loc.att
    loc.att     = @t <.> @a
    loc.occ     = (@p, @f) >.< @a
    loc.pmp     = M.singleton @loc.olab @loc.occ
    loc.pmpr    = M.singleton @loc.occ  @loc.olab
    loc.inss    = M.singleton @loc.alab [@loc.olab]
    loc.gen     = M.singleton @loc.olab @loc.alab
    lhs.ap      = M.singleton @p [@loc.occ]
    lhs.ofld    = [(@loc.olab, @lhs.flab)]

-- calculate representation of semantic function 
-- definitions per non-terminal and from it, calculate E_P
SEM Grammar | Grammar
     loc.sfp = repLocRefs @nonts.lfp @nonts.sfp
ATTR Nonterminals Nonterminal Productions Production Rules Rule [ || 
    sfp  USE {M.unionWith (S.union)} {M.empty} : SF_P  -- deps of non-locals
    ruleMap USE {M.union} {M.empty} : {M.Map MyOccurrence Identifier} 
    lfp  USE {M.unionWith (S.union)} {M.empty} : SF_P  -- deps of local attrs
    lfpr USE {M.unionWith (S.union)} {M.empty} : SF_P ]-- reverse 
SEM Production | Production
    loc.pll   = (@lhs.dty,getName @con)
    rules.pll = @pll 
    rules.pts = @children.pts
    lhs.fsInP = M.singleton @pll $ M.keys @children.fieldMap

ATTR Children Child [ ||
    pts USE {S.union} {S.empty} : {S.Set FLabel} ]

SEM Child | Child
    lhs.pts = S.singleton $ getName @name

ATTR Rules Rule [
    lfpf : SF_P ||
    usedLocals USE {(S.union)} {S.empty} : {S.Set MyOccurrence}]

SEM Rule | Rule
    loc.usedLocals = S.filter (\(MyOccurrence (_,f) _) -> f == "loc") @rhs.used
    loc.usesLocals = not $ S.null @loc.usedLocals
    (lhs.sfp,lhs.ruleMap,lhs.lfp,lhs.lfpr) = 
        foldr (\(f, a, b) (m',rm', l', lr') -> 
          let att = (@lhs.pll, f) >.< a
              rm  = M.insert att @rulename rm' 
              l   = if @loc.usesLocals && not b
                      then M.insert att @loc.usedLocals l'
                      else l'
              lr  = if @loc.usesLocals && not b
                     then S.fold (\k m -> M.insertWith (S.union) k 
                                 (S.singleton att) m) lr' @loc.usedLocals
                     else lr'
              sfpins = M.insert att (@rhs.used `S.union` fromHO) m'
              fromHO = maybe S.empty id (M.lookup hOcc @lhs.lfpf)
                where hOcc = (@lhs.pll, "inst") >.< (f, AnyDir)
              
            in if b
                then (m',rm, M.insert att @rhs.used l, 
                        S.fold (\k m -> M.insertWith (S.union) k 
                                (S.singleton att) m) lr @rhs.used)
                else (sfpins,rm,l,lr))
                        (M.empty,M.empty,M.empty,M.empty) @pattern.afs

ATTR Patterns Pattern [ ||
    -- the boolean represents whether this occurrence is 
    --   an transparent occurrence (only there to pass on dependencies)
    afs USE {++} {[]} : {[(FLabel, ALabel, Bool)]} ]

SEM Pattern | Alias
    lhs.afs = let isLocal = (@field == _LOC || @field == _INST)
               in [(getName @field, (getName @attr, dlhs @field), 
                    isLocal)] ++ @pat.afs

ATTR Rules Rule Expression HsTokensRoot HsTokens HsToken [
    -- the terminals of current production
    pts                : {S.Set (FLabel)} || ]

ATTR Rule Expression HsTokensRoot HsTokens HsToken [ ||
    used USE {S.union} {S.empty} : {S.Set MyOccurrence} ]

SEM Expression | Expression
    inst.tokens : HsTokensRoot
    inst.tokens = HsTokensRoot @tks
    tokens.pll  = @lhs.pll
    tokens.pts  = @lhs.pts
    lhs.used    = @tokens.used

-- reference to terminals of which some are local attributes 
SEM HsToken | AGLocal 
    lhs.used = 
        case getName @var `S.member` @lhs.pts of
          True  -> S.empty 
          -- local found without flabel
          False -> S.singleton $ (@lhs.pll, getName _LOC) >.< 
                        (getName @var, drhs _LOC)
-- includes both locals and attributes
-- locals will be replaced later by repLocRefs
SEM HsToken | AGField
    lhs.used = S.singleton $ (@lhs.pll, getName @field) >.< 
                                (getName @attr, drhs @field)
    
{
-- | Replace the references to local attributes, by his attrs dependencies
repLocRefs :: SF_P -> SF_P -> SF_P
repLocRefs lfp sfp =
    M.map (setConcatMap rep) sfp
    where rep :: MyOccurrence -> S.Set MyOccurrence 
          rep occ | isLoc occ   = setConcatMap rep $ 
                                    findWithErr lfp "repping locals" occ
                  | otherwise   = S.singleton occ
}


