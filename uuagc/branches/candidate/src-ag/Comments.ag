
-- code for generating a list of attributes and a list of
-- local variables as comments in the generated file

imports
{
-- Comments.ag imports
import List  (intersect, (\\))
import qualified UU.DData.Map as Map(toList) 
}


ATTR Productions Production Alternatives Alternative Rules Rule [ o_pretty:{Bool} | | ]

SEM Grammar
  | Grammar     loc.o_pretty = attrInfo @lhs.options

SEM Production
  | Production  loc.comment = let syn'     = map toString (Map.toList @syn)
                                  inh'     = map toString (Map.toList @inh)
                                  toString (a,t) = (getName a, case t of (NT nt) -> getName nt; Haskell t -> '{':t++"}" )
                                  chnn     = inh' `intersect` syn'
                                  inhn     = inh' \\ chnn
                                  synn     = syn' \\ chnn
                                  delSingle [x] = []
                                  -- delSingle [x] = [x, "      none"]
                                  delSingle xs  = xs
                              in Comment . unlines $
                                  (  delSingle (  "   inherited attributes:"
                                               : map (\(x,y) -> "      " ++ x ++ replicate ((20 - length x) `max` 0) ' ' ++ " : " ++ y) inhn
                                               )
                                  ++ delSingle (  "   chained attributes:"
                                               : map (\(x,y) -> "      " ++ x ++ replicate ((20 - length x) `max` 0) ' ' ++ " : " ++ y) chnn
                                               )
                                  ++ delSingle (  "   synthesized attributes:"
                                               : map (\(x,y) -> "      " ++ x ++ replicate ((20 - length x) `max` 0) ' ' ++ " : " ++ y) synn
                                               )
                                  ++ @alts.comments                                               
                                  )
                
SEM Alternatives [ || comments : {[String]} ] 
  | Cons lhs.comments = @hd.comment ++ @tl.comments
  | Nil  lhs.comments = []

SEM Alternative [ || comment : {[String]} ] 
  | Alternative lhs.comment = let fld'     = map toString @children.fields
                                  toString (a,t) = (getName a, case t of (NT nt) -> getName nt; Haskell t -> '{':t++"}" )
                              in  [  "   alternative " ++ getName @con ++ ":" ]
                                  ++ map (\(x,y) ->   "      child " ++ x ++ replicate ((14 - length x) `max` 0) ' ' ++ " : " ++ y) fld'
                                  ++ map (\x     ->   "      local " ++ getName x)  @rules.locVars




-- copied from DefaultRules, double computation :-(

ATTR Rules Rule Patterns Pattern [ | | locVars USE {++} {[]}:{[Name]} ]

SEM Pattern
  | Alias    lhs.locVars   = if @field == _LOC 
                                then [@attr]
                                else []
  

                
