
INCLUDE "CodeSyntax.ag"

imports
{
import CodeSyntax
import CommonTypes
import qualified Data.Map as Map
import Data.Map(Map) 
import Data.List(intersperse)
import UU.Scanner.Position(noPos)
import Expression
}

ATTR CSegments CSegment [ childNTNm : {Identifier}
                          fpInfo    : {Map (Identifier,Identifier) Expression}
                          | |
                          innerSemParts USE {++} {[("","","")]} : { [(String, String, String)] }
                        ]

ATTR CSegments          [ | | length : {Int} ]

SEM CInterface
  |  CInterface seg.childNTNm = Ident "" noPos
                seg.fpInfo    = Map.empty

SEM CSegments 
  |  Nil  lhs.length = 0
  |  Cons lhs.length = 1 + @tl.length 

SEM CSegment 
  |  CSegment lhs.innerSemParts = let inhs          = Map.keys @inh
                                      syns          = Map.keys @syn
                                      tElem t e f a = if Map.member (f,a) @lhs.fpInfo
                                                      then t
                                                      else e
                                      rhsPart       = concat.intersperse " ".map (mIdentWith (tElem "E" "I") @lhs.childNTNm) $ inhs
                                      lhsPart       = "(" ++ (concat.intersperse ",".map (mIdentWith (tElem "S" "O") @lhs.childNTNm) $ syns) ++ ")"
                                      funNamePart   = "_" ++ (concat.intersperse "_" . map getName $ inhs) 
                                  in [(lhsPart, rhsPart, funNamePart)]
{
mIdentWith :: (Identifier -> Identifier -> String) 
            -> Identifier -> Identifier -> String
mIdentWith g f a = "_" ++ getName f ++ (g f a) ++ getName a
}