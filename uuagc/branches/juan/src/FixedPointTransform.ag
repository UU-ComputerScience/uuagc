INCLUDE "AbstractSyntax.ag"
INCLUDE "Patterns.ag"
INCLUDE "Expression.ag"
INCLUDE "HsToken.ag"

imports
{
import Data.Set(Set)
import qualified Data.Set as Set
import qualified Data.Map as Map
import Data.Map(Map)
import qualified Data.Sequence as Seq
import Data.Sequence(Seq,(><))
import UU.Scanner.Position(noPos)
import Pretty
import Maybe
import HsToken
import HsTokenScanner
import Data.List(intersperse,intersect)
import qualified Data.List as List
import AbstractSyntax
import ErrorMessages
import Options(Options,modcopy,rename)
import HsTokenWriter
import FixedPointHelper(testGenFP,FPInfo(..))
}

ATTR Grammar Nonterminals Nonterminal Productions Production Rule Rules Expression  [ options : {Options} | | ]

ATTR Grammar Nonterminals Nonterminal Productions Production Rule Rules Pattern Patterns Expression HsTokensRoot HsToken HsTokens [ | | errors USE {Seq.><} {Seq.empty} : {Seq Error} ]

ATTR Nonterminals Nonterminal Productions Production Rule Rules Expression [ fpsMap : {Map NontermIdent (Map ConstructorIdent (Map Int (Map (Identifier,Identifier) (FPInfo Rule))))} | | ]

ATTR Grammar Nonterminals Nonterminal Productions Production Child Children Rules Rule Pattern Patterns TypeSig TypeSigs Expression [ | | output : SELF ]

ATTR Grammar [ | | fixedBlock : { PP_Doc } ]

ATTR Rule [ | | outputs : Rules ]

ATTR Productions Production Rule Rules Expression HsTokensRoot HsToken HsTokens [ nt : NontermIdent | | ]

ATTR Rule Rules Pattern Patterns Expression HsTokensRoot HsToken HsTokens [ con : ConstructorIdent | | ]

SEM Grammar | Grammar nonts.fpsMap = @fpsMap

SEM Nonterminal
  | Nonterminal
      prods.nt = @nt

SEM Production
  | Production
      rules.con = @con

-------------------------------------------------------------------------------
--         Managing Fixed Point Evaluators
-------------------------------------------------------------------------------

ATTR Nonterminals Nonterminal [ fpInfoIn : {Map NontermIdent (Map ConstructorIdent (Map Int (Map (Identifier,Identifier) (FPInfo Rule))))} | | ]
ATTR Productions Production   [ fpInfoIn :  {Map ConstructorIdent (Map Int (Map (Identifier,Identifier) (FPInfo Rule)))} | | ]
ATTR Rules Rule               [ attrsInFp : {Map Int [(Identifier,Identifier)]} | | ]
ATTR Rules Rule               [ | | fprules USE {>|-|<} {Map.empty} : {Map Int Rules} ]


-- ATTR Rules Rule [ | | fpSemFun USE {++} {[]} : {[([(Identifier,Identifier)],Rules)]} ]
-- ATTR Productions Production [ | | fpSemFun USE {`Map.union`} {Map.empty} : {Map ConstructorIdent [([(Identifier,Identifier)],Rules)]} ]
-- ATTR Nonterminals Nonterminal [ | | fpSemFun USE {`Map.union`} {Map.empty} : {Map NontermIdent (Map ConstructorIdent [([(Identifier,Identifier)],Rules)])} ]

SEM Grammar
  | Grammar      nonts.fpInfoIn = @fpsMap

SEM Nonterminal
  | Nonterminal  loc.fpInfoIn     = Map.findWithDefault Map.empty @nt @lhs.fpInfoIn

SEM Production
  | Production   loc.bottoms      = Map.findWithDefault Map.empty @con @lhs.fpInfoIn
                 loc.attrsInFp    = Map.map (Map.keys) @bottoms
                 loc.ntsInFp      = Map.map (Set.fromList.map fst $) @attrsInFp
                 rules.attrsInFp  = @attrsInFp
                 loc.e_attrgamma  = Map.map (Map.keys) $ Map.findWithDefault Map.empty @con @lhs.fpInfoIn
                 loc.e_nontgamma  = Map.map (Map.foldWithKey (\ k _ b -> Set.insert (fst k) b) Set.empty) $ Map.findWithDefault Map.empty @con @lhs.fpInfoIn
                 loc.rulesoutput  = @rules.output ++ Map.elems (fixpointrules @rules.fprules  @bottoms @ntsInFp)
                 loc.output       = Production @con @children.output @rulesoutput @typeSigs.output 

SEM Rules 
 | Cons  lhs.output = @hd.outputs ++ @tl.output

SEM Rule 
  | Rule (lhs.outputs,lhs.fprules) = case checkRuleFP @loc.output @lhs.attrsInFp of 
                                        Nothing   -> ([@loc.output], Map.empty)
                                        (Just i)  -> ([]           , Map.singleton i [@loc.output])


SEM Grammar | Grammar loc.output = Grammar @typeSyns
                                           @useMap
                                           @derivings
                                           @wrappers
                                           @nonts.output
                                           @pragmas
                                           @manualAttrOrderMap
                                           @paramMap 
                                           @contextMap
                                           @uniqueMap
                                           @augmentsMap
                                           @aroundsMap
                                           @fpsMap
                      loc.fpEval     = testGenFP @fpsMap
                      loc.fixedBlock = if @fpEval 
                                       then genFixedPointEval
                                       else empty

{
(>|-|<) :: Map Int Rules -> Map Int Rules -> Map Int Rules
m >|-|< m' = Map.unionWith (++) m m'

genFixedPointEval :: PP_Doc 
genFixedPointEval = let fun = [""
                              ,"drop_until_equal :: (Eq b) => (a -> a) -> (a -> b) -> a -> a"
                              ,"drop_until_equal f p a = let fa = f a"
                              ,"                         in if p fa == p a"
                              ,"                            then fa"
                              ,"                            else drop_until_equal f p fa"
                              ,""
                              ]
                    in vlist (map pp fun)


fixruletoRule :: (Rules,Set Identifier) -> Map (Identifier,Identifier) (FPInfo Rule) -> Rule
fixruletoRule (rs,nts) fpInfo = Rule Nothing allPatsP (Expression noPos (toRhs allPats pats_rhss collectedNts)) False (toOrigin nts pats fpInfo) False
  where toRhs p r psemf                    = getHsTokens (do initWriter
                                                             addTextN 2 "let"
                                                             setVTab
                                                             addText "next"
                                                             addText "("
                                                             setPatLhs subIn p
                                                             addText ")"
                                                             addTextN 2 "="
                                                             setVTab
                                                             addTextN 2 "let"
                                                             setVTab 
                                                             setRules subOut (lookupAttr' subIn subOutExpr') r
                                                             crlf
                                                             addTextInfo psemf
                                                             crlfbj
                                                             addText "in"
                                                             addText"("
                                                             setPatLhs subOut p
                                                             addText ")"
                                                             crlfbj
                                                             crlfbj
                                                             crlfbj
                                                             crlfbj
                                                             addText "in"
                                                             addText "drop_until_equal"
                                                             addText "next"
                                                             addText "fst"
                                                             addText "("
                                                             setBottoms (lookupAttr'') p
                                                             addText ")"
                                                         ) 
        toOrigin  _ _ _                    = "Fixed Point Evaluation" 
        subIn  f a                         = sub "E" f a
        subOut f a                         = sub "S" f a
        subOutExpr' s p _                  = HsToken s p
        sub    s f a                       = "_" ++ getName f ++ s ++getName a
        addTextInfo psemf                  = do addText "-- Here comes the invocations of all children that belong to this particular fixed point evaluator"
                                                mapM_ (\sem -> crlf >> addText ("-- **=? SEM: " ++ (getName sem))) psemf
        pats_rhss                          = map splitRule rs
        splitRule (Rule _ pat rhs _ _ _)   = (pat,rhs)
        (pats,rhss)                        = unzip pats_rhss
        attrfromPats (Constr name ps)      = concatMap attrfromPats ps
        attrfromPats (Product _ ps)        = concatMap attrfromPats ps
        attrfromPats (Alias f a p ps)      = (f,a):attrfromPats p ++ concatMap attrfromPats ps
        attrfromPats (Irrefutable p)       = attrfromPats p
        attrfromPats (Underscore _)        = []
        attrDefPats                        = concatMap attrfromPats pats
        cattrs                             = Map.keys fpInfo 
        missingAttrAtPats                  = cattrs List.\\ attrDefPats
        collectedNts                       = filter (not.isReservedIdentifier) $ Map.keys $ Map.fromList cattrs `Map.union` Map.fromList attrDefPats
        attrToPat (f,a)                    = Alias f a (Underscore noPos) []
        allPats                            = pats ++ map attrToPat missingAttrAtPats
        allPatsP                           = Product noPos allPats 
        lookupAttr'                        :: (Identifier -> Identifier -> String)
                                           -> (String -> Pos -> FPInfo Rule -> HsToken)
                                           -> Identifier
                                           -> Identifier
                                           -> Pos
                                           -> HsToken
                                           -> HsToken
        lookupAttr' g h f a pos e          = maybe e (h (g f a) pos) $ Map.lookup (f,a) fpInfo
        lookupAttr''                       :: (Pos -> a)
                                           -> (FPInfo Rule -> Pos -> a)
                                           -> Identifier
                                           -> Identifier
                                           -> (Pos -> a)
        lookupAttr'' e g f a               = maybe e g $ Map.lookup (f,a) fpInfo

fixpointrules :: Map Int Rules 
              -> Map Int (Map (Identifier,Identifier) (FPInfo Rule)) -- Bottoms
              -> Map Int (Set Identifier) -- Nonterminals
              -> Map Int Rule
fixpointrules mr mb mnt = Map.intersectionWith (fixruletoRule) (Map.intersectionWith ((,)) mr mnt) mb
 
addSemFuntoFPsMap :: Map NontermIdent (Map ConstructorIdent [(Map (Identifier,Identifier) (FPInfo Rule),Rules)])
                  -> Map NontermIdent (Map ConstructorIdent [([(Identifier,Identifier)],Rules)])
                  -> Map NontermIdent (Map ConstructorIdent [(Map (Identifier,Identifier) (FPInfo Rule),Rules)])
addSemFuntoFPsMap fpInfoMap fpSemRulesMap = Map.mapWithKey (\ntId m -> (Map.mapWithKey (\cId m' ->  map (\ (m'',_) -> (m'',maybe [] id (getRules ntId cId m'' fpSemRulesMap))) m') m)) fpInfoMap 

getRules :: NontermIdent 
         -> ConstructorIdent 
         -> Map (Identifier,Identifier) (FPInfo Rule) 
         -> Map NontermIdent (Map ConstructorIdent [([(Identifier,Identifier)],Rules)])
         -> Maybe Rules
getRules nt ct mfp m = do m'  <- Map.lookup nt m
                          m'' <- Map.lookup ct m'
                          let attrs' = Map.keys mfp 
                          let r = concatMap (\ (attrs,rules) -> if not.null $ intersect attrs attrs' 
                                                                then rules 
                                                                else []
                                            ) m''
                          return r

checkRuleFP :: Rule -> Map Int [(Identifier, Identifier)] -> Maybe Int
checkRuleFP (Rule _ pat expr _ _ _) fpAttrs = 
   let attrsPat   = getAttrsPat pat
       attrsExpr  = getAttrsExpr expr
       inter  = Map.keys. Map.filter (id) . Map.map (interCheck attrsPat attrsExpr) $ fpAttrs
       interCheck p e y = interCheckE p y && interCheckE e y
       interCheckE :: [(Identifier,Identifier)] -> [(Identifier,Identifier)] -> Bool
       interCheckE e y = not.null.intersect e $ y
   in if null inter
      then Nothing
      else return.head $ inter

getAttrsPat :: Pattern -> [(Identifier,Identifier)]
getAttrsPat (Constr _ pats)      = concatMap getAttrsPat pats
getAttrsPat (Product _ pats)     = concatMap getAttrsPat pats
getAttrsPat (Alias fld attr _ _) = [(fld,attr)]
getAttrsPat (Irrefutable pat)    = getAttrsPat pat
getAttrsPat (Underscore _)       = []

getAttrsExpr :: Expression -> [(Identifier,Identifier)]
getAttrsExpr (Expression _ tks) = concatMap getAttrsHsToken tks

getAttrsHsToken :: HsToken -> [(Identifier,Identifier)]
getAttrsHsToken (AGField fld attr _ _) = [(fld,attr)]
getAttrsHsToken _                      = []
}

