imports
{
import Data.List(elemIndex,partition)
import Control.Monad(liftM)
import qualified Data.Array as Array
import Data.Array((!),bounds,inRange)
import Data.List(sort,mapAccumL,find)
import Data.Graph
import qualified Data.Tree  as Tree
import SequentialComputation
import SequentialTypes
import CodeSyntax
import GenerateSeqCode
import GrammarInfo
}

------------------------------------------------------------------
-- Building a mapping from Vertices to Ints
------------------------------------------------------------------
{
getNtName :: Type -> Nonterminal
getNtName (NT nt) = nt
getNtName _       = nullIdent
}

-- Collect attribute occurrences
{
data AltAttr = AltAttr Name Name Bool 
               deriving (Eq, Ord)
}
ATTR Children Child Rules Rule Patterns Pattern [ | | gathAltAttrs USE {++} {[]} : {[AltAttr]} ]
SEM  Alternative
  |  Alternative  loc.gathAltAttrs =  [ AltAttr _LHS inh True | inh <- Map.keys @lhs.inh ]
                                      ++ @children.gathAltAttrs ++ @rules.gathAltAttrs

SEM  Child
  |  Child  loc.maptolocal = Map.isEmpty @inh && Map.isEmpty @syn
            lhs.gathAltAttrs = if  @maptolocal
                                   then [ AltAttr _LOC @name True ]
                                   else [ AltAttr @name syn True | syn <- Map.keys @syn ]
SEM  Pattern
  |  Alias lhs.gathAltAttrs = [AltAttr @field @attr (@field == _LOC)]

ATTR Rules Rule Patterns Pattern [ altAttrs : {Map AltAttr Vertex} | | ]
SEM  Alternative
  |  Alternative rules.altAttrs = Map.fromList (zip @gathAltAttrs [@lhs.vcount..])

-- Information passed to Pattern
ATTR  Children Child 
      [  | |  nts USE {Seq.<>} {Seq.empty} : {Seq (Name,Nonterminal)} 
              inhs USE {Seq.<>} {Seq.empty} : {Seq (Name,Attributes)} ]
SEM  Child
  |  Child  lhs.nts = Seq.single (@name,getNtName @tp)
            lhs.inhs = Seq.single (@name,@inh)
ATTR  Rules Rule
      [  childNts : {Map Name Nonterminal} 
         childInhs : {Map Name Attributes} | | ]
SEM  Alternative
  |  Alternative  rules.childNts = Map.fromList (Seq.toList @children.nts)
                  rules.childInhs = Map.fromList (Seq.toList @children.inhs)

-- Collect CRules
ATTR  Children Child Rules Rule
      [ | | gathRules USE {Seq.<>} {Seq.empty} : {Seq CRule} ]
SEM  Alternative
  |  Alternative  loc.inhRules = [ cRuleLhsInh inh @lhs.nt @con tp | (inh,tp) <- Map.assocs @lhs.inh ]
                  loc.gathRules = @inhRules ++ Seq.toList (@children.gathRules Seq.<> @rules.gathRules)

SEM  Child
  |  Child  loc.gathRules = if  @maptolocal
                                then Seq.single (cRuleTerminal @name @lhs.nt @lhs.con @tp)
                                else Seq.fromList [ cRuleRhsSyn syn @lhs.nt @lhs.con tp @name (getNtName @tp) | (syn,tp) <- Map.assocs @syn]

SEM  Rule
  |  Rule  loc.defines = let  tp field attr  | field == _LOC = Map.lookup attr @lhs.allTypeSigs
                                             | field == _LHS = Map.lookup attr @lhs.syn
                                             | otherwise = Map.lookup attr (Map.find field @lhs.childInhs)
                         in Map.fromList  [  (Map.find aa @lhs.altAttrs, (field,attr,(tp field attr)))
                                          | aa <- @pattern.gathAltAttrs, let AltAttr field attr _ = aa ]
           loc.gathRules =  let childnt field = Map.lookup field @lhs.childNts
                            in Seq.fromList [ CRule attr False True @lhs.nt @lhs.con field (childnt field) tp @pattern.pp @rhs.pp @defines @owrt @origin | (field,attr,tp) <- Map.elems @defines ]

-- Giving them a number
ATTR  Productions Production Alternatives Alternative
      [  | vcount : Int 
         | rules USE {Seq.<>} {Seq.empty} : {Seq (Vertex,CRule)}]
SEM  Grammar
  |  Grammar  prods.vcount = 0
SEM  Alternative
  |  Alternative  lhs.rules = Seq.fromList (zip [@lhs.vcount..] @gathRules)
                  lhs.vcount = @lhs.vcount + length @gathRules

-- Direct dependencies
ATTR Productions Production 
     Alternatives Alternative 
     Rules Rule [ | | directDep USE {Seq.<>} {Seq.empty} : {Seq Edge} ]
SEM  Rule
  |  Rule  lhs.directDep
             = let  defined = Map.keys @defines
                    used =  [ Map.find (AltAttr field attr True) @lhs.altAttrs | (field,attr) <- @rhs.usedAttrs]
                            ++ [ Map.find (AltAttr _LOC attr True) @lhs.altAttrs | attr <- @rhs.usedLocals ++ @rhs.usedFields ]
               in Seq.fromList [ (x,y) | x <- used, y <- defined ]

-------------------------------------
-- NT-Attributes
-------------------------------------
ATTR  Productions Production 
      [ | acount : Int |  ntattrs USE {Seq.<>} {Seq.empty} : {Seq (Vertex,NTAttr)} 
                          aranges  USE {Seq.<>} {Seq.empty} : {Seq (Int,Int,Int)}]

SEM Grammar
  | Grammar prods.acount = 0

SEM Production
  | Production loc.ntattrs =  [NTAInh @nt inh tp | (inh,tp) <- Map.assocs @inh ]
                              ++ [NTASyn @nt syn tp | (syn,tp) <- Map.assocs @syn ]
               lhs.ntattrs = Seq.fromList $ zip [@lhs.acount ..] @ntattrs
               lhs.acount = @lhs.acount + Map.size @inh + Map.size @syn
               lhs.aranges =  Seq.single
                                (@lhs.acount
                                ,@lhs.acount + Map.size @inh
                                ,@lhs.acount + Map.size @syn + Map.size @inh - 1)

------------------------------------------------------------------
-- Pass structure up
------------------------------------------------------------------
ATTR Productions Production [ | | prods USE {++} {[]} : {[(Nonterminal,[Constructor])]} ]
SEM  Production
  |  Production  lhs.prods = [(@nt,@alts.cons)]
ATTR Alternatives Alternative [ | | cons USE {++} {[]} : {[Constructor]} ]
SEM  Alternative
  |  Alternative  lhs.cons = [@con]

------------------------------------------------------------------
-- Collect type signatures
------------------------------------------------------------------
ATTR TypeSigs TypeSig [ | typeSigs : {Map Name Type} | ]
SEM Alternative
  | Alternative typeSigs.typeSigs = Map.empty
SEM TypeSig
  | TypeSig lhs.typeSigs = Map.insert @name @tp @lhs.typeSigs

ATTR Rules Rule Patterns Pattern [ allTypeSigs : {Map Name Type} | | ]
SEM  Alternative
  |  Alternative rules.allTypeSigs = @typeSigs.typeSigs

------------------------------------------------------------------
-- Invoking sequential computation
------------------------------------------------------------------
SEM Grammar
  | Grammar loc.ruleTable = Array.array (0,@prods.vcount-1) (Seq.toList @prods.rules)
            loc.attrTable = Array.array (0,@prods.acount-1) (Seq.toList @prods.ntattrs)
            loc.attrVertex = Map.fromList (map swap (Seq.toList @prods.ntattrs))
            loc.tdpToTds  = [ (s, maybe (-1) (\v -> Map.find v @attrVertex) (ntattr cr)) | (s,cr) <- Seq.toList @prods.rules]
            loc.tdsToTdp  =  let  eq (_,v) (_,v') = v == v'
                                  conv ((s,v):svs)  | v == -1 = Nothing
                                                    | otherwise = Just (v,s:map fst svs)
                             in mapMaybe conv (eqClasses eq @tdpToTds)
            loc.directDep = Seq.toList @prods.directDep
            loc.info      = Info { tdsToTdp   = Array.array (0,@prods.acount-1) @tdsToTdp
                                 , tdpToTds   = Array.array (0,@prods.vcount-1) @tdpToTds
                                 , attrTable  = @attrTable
                                 , ruleTable  = @ruleTable
                                 , lmh        = Seq.toList @prods.aranges
                                 , prods      = @prods.prods
                                 , wraps      = @wrappers
                                 , cyclesOnly = not (visit @lhs.options)
                                 }
                             where def [] = -1
                                   def (v:vs) = v
            loc.(cInterfaceMap,cVisitsMap,cyclesErrors) =
                              case computeSequential @info @directDep of
                                           SeqResult    cim cvm -> (cim,cvm,[])
                                           LocLocCycle  errs ->  (error "No interfaces for cyclic AG"
                                                                 ,error "No visit sub-sequences for cyclic AG"
                                                                 ,map (loclocCycleErr @ruleTable (visit @lhs.options)) errs)
                                           DirectCycle  errs ->  (error "No interfaces for cyclic AG"
                                                                 ,error "No visit sub-sequences for cyclic AG"
                                                                 ,map (directCycleErr @attrTable @ruleTable (visit @lhs.options)) errs)
                                           InducedCycle cim errs ->  (cim
                                                                     ,error "No visit sub-sequences"
                                                                     ,map (inducedCycleErr @attrTable cim) errs)
            lhs.errors := (if withCycle @lhs.options then Seq.fromList @cyclesErrors else Seq.empty) 
                          Seq.<> (if visit @lhs.options && null @cyclesErrors then @missingTypeSigs else Seq.empty)
                          Seq.<> @prods.errors

------------------------------------------------------------------
-- Generate CGrammar
------------------------------------------------------------------
-- Pass InterfaceMap down and select the Interface in the Production
ATTR Productions Production [ cInterfaceMap : CInterfaceMap | | ]
SEM  Production
  |  Production  loc.cInters = sem_CInterface (Map.find @nt @lhs.cInterfaceMap)

-- Pass VisitMap down and select the CVisits in the Alternative
ATTR Productions Production Alternatives Alternative [ cVisitsMap : CVisitsMap | | ]
SEM  Alternative
  |  Alternative loc.cVisits = sem_CVisits (Map.find @con (Map.find @lhs.nt @lhs.cVisitsMap))

-- Now just build the CGrammar
SEM  Grammar
  |  Grammar  loc.cGrammar = sem_CGrammar_CGrammar @prods.cProductions
SEM  Productions [ | | cProductions : T_CProductions ]
  |  Cons  lhs.cProductions = @hd.cProduction `sem_CProductions_Cons` @tl.cProductions
  |  Nil   lhs.cProductions = sem_CProductions_Nil
SEM  Production [ | | cProduction : T_CProduction ]
  |  Production  lhs.cProduction = sem_CProduction_CProduction @nt @inh @syn @alts.cAlternatives @cInters
SEM  Alternatives [ | | cAlternatives : T_CAlternatives ]
  |  Cons  lhs.cAlternatives = @hd.cAlternative `sem_CAlternatives_Cons` @tl.cAlternatives
  |  Nil   lhs.cAlternatives = sem_CAlternatives_Nil
SEM  Alternative [ | | cAlternative : T_CAlternative ]
  |  Alternative  lhs.cAlternative = sem_CAlternative_CAlternative @con @cVisits @children.fields @children.terminals

-- Collect terminals
ATTR Children Child  [ | | terminals USE {++} {[]} : {[Name]} ]
SEM Child
  | Child lhs.terminals = if @maptolocal then [@name] else []

------------------------------------------------------------------
-- Call CGrammar
------------------------------------------------------------------
SEM  Grammar
  |  Grammar  (prods.seqDecls,loc.missingTypeSigs)
                             = let  inh = Inh_CGrammar  { options_Inh_CGrammar = @lhs.options
                                                        , wrappers_Inh_CGrammar = @wrappers}
                                    syn = wrap_CGrammar @cGrammar inh
                               in (decls_Syn_CGrammar syn, missingTypeSigs_Syn_CGrammar syn)

SEM  Productions [ seqDecls : {[Decls]} | | ]
  |  Cons  hd.seqDecls = head @lhs.seqDecls
           tl.seqDecls = tail @lhs.seqDecls
SEM  Production [ seqDecls : {Decls} | | ]
  |  Production  loc.seqDecls = @lhs.seqDecls

{
swap (a,b) = (b,a)

showPath :: Table CRule -> [Vertex] -> [String]
showPath ruleTable path
  =  let  look a | inRange (bounds ruleTable) a = [ruleTable ! a]
                 | otherwise = []
          showOrigin cr  | getHasCode cr && getName (getAttr cr) /= "self" = prettyCRule cr ++ " (" ++ show (getPos (getAttr cr)) ++ ")"
                         | otherwise = prettyCRule cr
     in map showOrigin (concatMap look path)

loclocCycleErr :: Table CRule -> Bool -> (Vertex,[Vertex]) -> Error
loclocCycleErr ruleTable o_visit (s,path)
  =  let cr = ruleTable ! s
         attr = getAttr cr
         nt = getLhsNt cr
         con = getCon cr
     in LocLocCirc nt con attr o_visit (showPath ruleTable path)

directCycleErr :: Table NTAttr -> Table CRule -> Bool -> (Edge,[Vertex]) -> Error
directCycleErr attrTable ruleTable o_visit ((v1,v2), path)
  = let (NTASyn nt a1 _) = attrTable ! v1
        (NTAInh _  a2 _) = attrTable ! v2
    in DirectCirc nt a2 a1 o_visit (showPath ruleTable path)

inducedCycleErr :: Table NTAttr -> CInterfaceMap -> Edge -> Error
inducedCycleErr attrTable cim (v1,v2)
  = let (NTASyn nt a1 _) = attrTable ! v1
        (NTAInh _  a2 _) = attrTable ! v2
        cinter = Map.find nt cim
    in InducedCirc nt a2 a1 cinter
}
